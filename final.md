<style>
	.todo{ color:red }
</style>

#Orange Street

## <a name="casing"></a>Casing [cont.](#contents)

###Hub Case

The Hub case is 3D printed. It was designed to hold the Raspberry Pi in place through the use of screws and nuts. It is also designed to have room for the XBee component needed. <style>
	.todo{ color:red }
</style>

#Orange Street

## <a name="contents"></a>Contents
* [Client Interaction](#client-interaction)
* [Sensor](#sensor)
* [Hub](#hub)
* [Server](#server)
* [Visualisation](#visualisation)
	- Clock
	- Website

<p class="todo">REFERENCE MINUTES THROUGHOUT</p>

### <a name="client-interaction"></a>Client Interaction - [cont.](#contents)

####Aims
Our client interaction brought to light these main issues to consider in our project. 

**They do not want to think about the noise:**   
The user talked a lot about having to worry about remembering specific times they were caused inconvenience by the noise outside and then provide evidence of those inconveniences. Therefore the project needs to store data and visualise it in a way that could be presented as evidence of their inconvenience. Also from this we can gather that the user does not really want any real interaction with the device as it would mean them thinking about the noise. The point of the device should be that it runs autonomously (to create peace of mind for the user) collecting data for the user to visualise and use as evidence at their discretion.

**Solution needs little to no interaction, running in the background:**  
The user expects the device to have a maintenance level of a device akin to a router. They expect some general maintenance but they do not want to be too involved with it, ie worrying about battery life all the time.

**A long term solution:**  
Along the lines of the other two themes before, the user wanted the system to be robust and sustainable. During the meeting the user said that this year so far wasn't as bad as last and didn't want to complain this year if it was to change next and get worse. Therefore the end result of the project should be something that the user can maintain on their own.

**People should be aware of their own noise levels:**  
The client talked a lot about wanting the people in the street to know how noisy they are being. Points being brought up suggesting signs that had the decibel reading on them so that people can visualise the noise like a road sign that turns on when you are going too fast. Although, as we wouldn't be able to enforce the sound level it could possibly encouraging even challenging people in the street to be loud to try and make the sign go off.

<p class="todo">DO WE WANT TO INCLUDE A LIST OF GOALS TO ACHIEVE?</p>

#####Meeting ONE

We had to speak with the clients before we started to formulate a solution. We had to know what they wanted, so that we could make a solution that best filled their needs. To prepare for this we researched proper interviewing techniques by reading: *“Interviewing users: How to Uncover Compelling Insights (Steve Portigal, 2013)”*.  

The main lesson we took from the Portigal book was that we needed to let the client talk. We did not want to steer their answers in any direction. We organised roles amongst ourselves, with a leader asking questions and the rest taking notes. If the note takers had any questions we made sure they were asked at the end of the question so that the client did not lose track.

Our intended outcome for this meeting was to have an incite into our clients perception of the problem they are having, whereby we can devise a method in which to solve said problem. We had an idea of the client's problem before we went into the meeting, based on what we were told in the project brief. Therefore, in preparation we made a list of questions that we felt we needed answered to gain a better understanding.<span class="todo"> REFERENCE ORIGINAL QUESTION SHEET</span>. We then trimmed down our question list intending to allow our client to talk as freely as possible. <span class="todo">REFERENCE SECOND QUESTION SHEET</span> 

<p class="todo">INCLUDE RECORDING</p>

#####Meeting TWO

We spoke to another client that was meant to be present at the original meeting but was unable to make it. They are a landlord of Orange Street tenants living next to a popular club called ‘The Ballroom’. In this meeting we followed the same layout as set in the first meeting, making one person take the lead and the others taking notes, we also followed the same structure of questions.

<p class="todo">INCLUDE SEB RECORDING AND QUOTES</p>

<p class="todo">DO WE INCLUDE PHOTO OF THE RESIDENTS HOUSES ON GOOGLE MAPS?</p>

<img src="images/OrangeStreet_dist.jpg">

#####Vendor Communication

We also tried to speak to other people, pubs and bars in the area to try and gain a greater understanding of the issues that were present in the street and what people were doing to try and solve them.  

A message was sent out to three of the main purported culprits of noise on the street: The Maori Bar, The Seven Stars and Ballroom. The message said: 
>Hello, three other Kent students and I have undertaken a project whereby we are looking into sound around Orange Street. We were wondering how you deal with sound i.e. keeping it contained or if there is a way you try and stop it from spilling into the street. 
>
>Thank you  

The Maori Bar responded with: 
>Hello Matthew thanks for your message, our building is soundproofed in the walls and we make sure the door is kept shut so to trap and muffle as much of the sound as possible. We also monitor our sound levels regularly with a decibel reader.  
>
>Orange Street is a very busy street especially on a Friday and Saturday night and attracts a lot of foot traffic. Of course telling people to keep quiet is near enough impossible as they pass between venues. We don't have live music or DJ's but The Seven Stars and The Ballroom do. We are a small venue with only about 40 people in at one time on average. We would be interested in your findings in your project. Keep us posted.
>
>The Maori Bar team.

This shows that there is an awareness that the street is loud but it can be hard to police outside of the venue. It was also interesting that they mentioned keeping the door closed as the door being opened and closed with the occasional noise leaking out was cited as a large source of annoyance by the clients.  

The Seven Stars allowed us to come and talk to a manager. They said they maintain the noise by trying to keep the doors and windows shut as much as possible and they have a set of double doors so that the sound is muffled when people are coming and going. They also said that they had decibel readers that they checked to make sure that the inside noise was in accordance with the set sound levels. They know that people are noisy when they leave the establishment but he said there was nothing that could be done about that as it is a problem that comes with the clientele.  

Unfortunately The Ballroom did not get back to us.  

####Noise Law

We looked into noise laws. We did this so that we could understand, firstly, if the way we were collecting data was legal and to see if the data we provide to the client would be of any use to them.  

The main thing we found were that there are noise laws in place but they only apply to residential premises according to the ***Noise Act 1996 - Non commercial only. This law only relates to noise that is coming from a residential premises such as neighbours, it does not affect licensed premises.***  

We also found that police can close a premises based on the ***161 Closure orders for identified premises - (1) A senior police officer may make a closure order in relation to any relevant premises if he reasonably believes that: (a) there is, or is likely imminently to be, disorder on, or in the vicinity of and related to, the premises and their closure is necessary in the interests of public safety, or  (b) a public nuisance is being caused by noise coming from the premises and the closure of the premises is necessary to prevent that nuisance.***

The following email is from the Environmental Health department of Canterbury County Council. This is the department that handles any noise complaints regarding both residential and commercial premises. We enquired to them about noise laws.

>Dom  
>
>In response to your enquiry each premises is based on its own merits, hours of operation and location so we don’t have any set levels for Canterbury District. Two documents which may be of use to you are the Control of Noise at Work  
>
>Regulations 2005 which deals with operators requirements for their staff and BS:4142
>  
>The Method for rating and assessing industrial and commercial sound - this looks at how and where to measure sound in mixed residential and business communities. I hope this helps  
>
>Tricia  

The first document mentioned is in relation to the noise levels that are acceptable for their staff and people working on the premises rather than those sounds that are heard from outside the premises so this is of less of a concern to us. Although, it can still be found [here](http://www.legislation.gov.uk/uksi/2005/1643/contents/made). 

The other document mentioned is owned by the British Standards Institute and incurs a cost if we wish to use it. A brief description of the document said the standard is used by the council and describes methods for rating and assessing:

* Helps assess sound levels at proposed new residential premises 
* Enables the investigation of complaints by determining sound levels 
* Reduces the likelihood of financial penalties 
* Supports current UK planning guidance and Environment Agency guidance sound of industrial or commercial nature.

We also looked into licensing reviews and found that anyone with evidence suggesting there is a problem can request a licence review from the council as long as it comes under one of the following:

* Crime and/or disorder 
* Public nuisance 
* Public Safety 
* Prevention of harm to children

In this case, the noise generated from the pubs and or clubs would be classed as a nuisance. 

When making a review request evidence needs to be provided to support the case that you are making. This evidence can be in multiple forms such as:

* a diary or record of events or incidents 
* photos or video evidence
* sound recordings
* a record of complaints made to the responsible authorities about the premise

<style>
	.todo{ color:red }
</style>

#Orange Street

### <a name="hub"></a>Hub [cont.](#contents)

Image Here
(The finished Hub, requiring only ethernet and power it is capable of coordinating the entire network.)

The Hub, a Raspberry Pi Model B+ running Raspbian Jessie Lite, is the coordinator on the network. All traffic is sent to it. It handles data coming in from the sensor and requests from the clock. The clock can request decibel averages of the past 24 hours using the Hub as a middleman, the Hub then forwards this request to the web server and returns the result to the clock. The sensors submit their sampled data to the hub in order for this to then be sent forward to the web server. 
The Hub takes into account that it may not be able to reach the web server for various reasons, and will try multiple times to connect. If it fails with sensor data it will save this in the SD card on the Pi, if it cannot request data for the clock it will return an error instead and the clock can react accordingly. 
Upon a series of failed attempts, once a successful attempt is made the Hub will transmit all stored data and delete it afterwards to clear space in memory. 
The Hub is able to handle data coming in from multiple sources at once, packet fragmentation and identifying nodes on the network.
The Hub required a case that could fit the XBee module in, we 3D printed a case that could handle this requirement and left space to fit other modules in as well if needed.

The hub is the coordinator for all the data going through our network. It is located in our clients house, connected to their router and powered by the mains to make sure that it is constantly running. It is always listening for incoming data from our sensor and clock. When the hub collects data from a node on the network it has to then decides what action to take with this data. 


The hub is comprised of multiple parts: [Board](#hub_board), [Communication / XBee](#hub_xbee), [Case](#hub_case)

######<a name="hub_board"></a>Board

The hub uses a Raspberry Pi Model B+ running Raspbian Jessie Lite

######<a name="hub_xbee"></a>Communication / XBee
######<a name="hub_case"></a>Case

#### Initial Premise

Unlike the sensor, power consumption was not an issue as the client told us that we could connect to a power outlet. It didn't need to be outside the clients premisses either. This meant we could use any feasible board for this role. We needed a board that could offer the most useful functionality towards our project.

The hub was required to be a middleman between sensors and the web server, forwarding traffic onto the website over ethernet and handling any heavy processing. Initially we planned on using an FRDM-K64F board due to familiarity and easy access to them within the University. 

#### Hub Hardware
#####Iteration ONE
######FRDM K64F

Image Here
(FRDM K64F Board)

The FRDM-K64F board has a lot of unneeded functionality. It has an unnecessary amount of sensors on the board itself (temperature sensor and accelerometer for example) which wouldn't add to our project benefits. Although as previously stated we are testing this board because of its availability and our familiarity with it. We are familiar with this board and we know that it has a shield that has the ability to interface with an XBee which is what we decided to use for our networking. <span class="todo">(insert link to networking decisions)</span> Using the board would not be an issue, as we have had extensive skill in handling and programming it. Including the MBED Application shield would benefit us in providing pins designed for an XBee module to interface with. It also offers an LCD display for reporting information back to the client, which could be useful for showing basic messages. However the shield does offer a lot of useless additions as well. Introducing more sensors and obstructing every pin on the FRDM makes it unlikely to be a realistic option for our Hub.

<p class="todo">Here I was going to include my case design implementation for the hub, but it went on for a while, would you like me to do that in its own page?</p>

####Research Into other Boards

#####Arduino Uno

Considering the Arduino Uno for the hub as a likely candidate for the fact that the board itself does not have any sensors that would be considered unnecessary like on the FRDM K64F. It is programmable in C much like the K64F so will essentially use the same code. The main reason for choosing this board would be to trim the unessential things from our current solution. The Uno is also a well known board that is vastly documented. 

Unlike the K64F the Uno lacks an ethernet port built in. To remedy this we would have to add an Arduino shield capable of offering ethernet such as the Arduino Ethernet shield. The shield while similar to the MBED Application shield provides the ability to transmit more than just data along ethernet, it could provide power too, although this means adding the PoE (Power over Ethernet) component. This added functionality means the possibility for less wires, this means easier instillation for the client as only one connection would be required. There are libraries that exist to help use the shield and it’s functionality and the board offers a lot of useful debug information regarding current status with sending data, making it easier to work with.

With the problem of ethernet solved this only leaves connection to XBee out. In order to fix this we would have to either, include another [shield](http://uk.rs-online.com/web/p/products/6961670/?grossPrice=Y&cm_mmc=UK-PLA-_-google-_-PLA_UK_EN_Semiconductors-_-Semiconductor_Development_Kits&mkwid=s8484M9Xf_dc|pcrid|88057061283|pkw||pmt||prd|6961670&gclid=Cj0KEQjwid63BRCswIGqyOubtrUBEiQAvTol0WdagHobLZ9zO5iXOsR0-jdPUrM43OJ-dTZv86HIMcgaAkHy8P8HAQ) that had a breakout for the XBee or physically wiring up an XBee. Wiring up an XBee would require soldering the required pins on the XBee to wires that we could plug into the headers of the ethernet shield. If we choose to have the ethernet shield with the PoE module the XBee shield would probably not fit and therefore we would have to solder the XBee to the board. In circumstance of soldering the XBee it would also lead to being unable to then modify the firmware settingson the module without desoldering first leading to more spendature of time. Otherwise we could use the shield on its own, meaning we could reconfigure the XBee at any time.

#####Arduino Yun

INSERT IMAGE OF YUN AND SYSTEM DIAGRAM (IMAGE 0)

The Arduino Yun is a very unique Arduino board, as it offers two processors. The AR9331 handles a Linux distribution while the ATMega32U4 handles the board. This means we can run an Operating System with all the benefits that brings on this board. The board comes with an ethernet port and WiFi as well, making it immediately more ideal than the previous two boards mentioned. The board also comes with an SD card port for supplying the Operating System, so in theory a large SD card would allow data logging and more storage in general. The board itself can run Arduino sketches which can interface with shell scripts running on the Linux distro, although the two processors are kept separate; bridging is possible due to a library provided.

However the Yun lacks a great deal of hardware support in terms of volatile memory only offering  64MB of DDR2 ram with 16MB of flash, 9 of which is taken by the Linux distribution. With this considered a better alternative would be something like a Raspberry Pi which could offer more memory and more Operating Systems varieties. The price of a Yun is higher than previous entries, averaging around £50 which is more than double the price of an Uno. 

#####Micro Server

It is plausible to use a Micro Server in place of the Hub. The server could have a serial programmer connected to a XBee and use programs to read and access the data coming in. Using a Micro server would give huge benefits in terms of processing power, data storage and security. We could have our own choice of operating system and hardware. Data could come in and be backed up internally, then processed to be sent off. However price and size could cause issues, as these servers do not often come cheap and are a lot larger than other potential solutions. They can also become quite loud and considering noise is what we are trying to help our client with it is probably not an ideal solution furthermore it would draw a lot more power than a development board meaning it could have a visible cost impact on the client.

#####Raspberry Pi

The Raspberry Pi is a well known mini computer in its own right and full of IoT uses too. Following on from the Microserver idea, the premise of having an operating system was very appealing. Especially the idea of being able to remotely access the Hub, in which both the Microserver, Yun and Pi could provide this. The Pi while being smaller and considerably cheaper than its Microserver counterpart did lack internal hardware to boot, but for the purpose we had planned it was more than adequate. It would’t be noisy either. 

The Pi was a good middleground between the Yun and the Microserver. It didn’t have as many Operating Systems to chose from compared to the Microserver (due to its Arm architecture) but it did offer a good selection of Operating Systems in terms of networking and much more compared to the Arudino Yun. Its price was not as expensive as the Yun or the Microserver, averaging around £25. 

Internal storage could be managed using a SD card of any size meaning data logging was possible as well. With this being built in as well as an ethernet port it has many advantages over previous entries. The only piece of hardware that is lacking for what we need is an XBee connection. Although solutions are the same as the Arduino Uno, either we use a shield with XBee breakouts or we physically wire an XBee up.

However with all this, the Pi did lack the speed of other boards that didn’t require a OS to maintain. It also didn't offer built in WiFi unlike the Yun, but we were unlikely to use this anyway due to potentially changing security of a WiFi network. 

#####Conclusion

We decided to use a Raspberry Pi (Model B+ 512MB) over other solutions. While the Arduino and FRDM K64F boards offered speed, they lacked remote accessing and long term storage and would require more adaptions to work around this. The Microserver was too large, expensive and potentially noisy. The Yun while very promising lacked internal hardware to match the Pi as well being double the price. The Pi offered a full operating system while maintaining a small size, better secure networking and remote access for updating on the network. This meant that if a bug was found in our code we could remotely update in on the hub, we would also be able to access any logged debug information from the program. 

#####Iteration Two (FINAL)
######Raspberry Pi (Model B+)
We decided to use a Raspberry Pi (Model B+ 512MB). The Pi offered a full operating system, better secure networking and remote access for updating on the network. This means that if a bug is found in our code while the hub is deployed in our clients house we could remotely update in on said hub. In the same way we would also be able to access any logged debug information from the program.

######How to move forward with the pi

The Model B+ will be supplied by the university. The operating system of choice was Raspbian Jessie Lite because it is the officially supported OS of the Pi therefore, recommended by the developers of the Pi. The Pi will have to be connected to the XBee over serial, however in order to use these ports they have to be masked by systemd to force them to be free on startup. 

Then we need to write a program capable of handling incoming AT packets from serial, interpret them and respond accordingly. <span class="todo"><- link to code for this</span> 

The program will be written in Python 3 as its easily available on the Pi and offers all the functionality required to create a robust networking program. We will have to modify /etc/rc.local to contain “sudo python hub.py” so that the script will start every time the Operating System starts. If the network was down, or errors occurred on transmit then the Pi will save data locally, and retry on its next attempt.

####Language of Choice: Python <span class="todo">is this description of code or why python was chosen?</span>

Why Python

We chose Python because it was easily available on the Pi, had plenty of documentation supporting it and is a very easy language to read from another developers standing. In terms of interfacing it with serial and the network there are plenty of libraries that exist to make this as simple and efficient as possible, we have decided to use PySerial and Requests to handle these requirements. 

Python Libraries

PySerial and Requests simplified any complications we may have had from writing our own initial libraries as well as having organised documentation to support them. They abstracted a lot of complicated hardware tasks (such as interrupt handling on GPIO pins) and communicating over the network. Other libraries we plan on using are those standard to Python, time for handling timing operations, random for random calculations, threading to handle multiple tasks to name a few.

####Coordinator on Network

The Hubs most important role will be that of the coordinator on the network, it is the centre point. Due to how XBees address each other, it is very easy to send data straight to coordinator using its predefined 64bit address (0x0000000000000000).  The Hub could address any node on the network and with this could determine which nodes were which and if they were still within range.

<p class="todo">insert picture system diagram pi with zigbee</p>

####AT Mode 
Image Here
(a single sensor to Hub to the server. Hub reads in all data it receives which is only from one source, no errors.)

Initially we used AT mode for working with one sensor, however problems would soon arise when we planned to add multiple sensors to our network. The problem was that it would become impossible to identify who was sending data causing different sensor readings to become mixed up across transmissions. Using one sensor was fine because only one source of traffic with sensor readings was expected, the clock wouldn’t interfere as this was a different format of data. The solution to this was to expand into API mode, which allowed us to identify individual sensors on the network and solve this particular problem

Image HERE
(Multiple sensors to Hub to server, Hub reads in data without knowing sources, data is merged together and becomes inoperable.)


####API Mode

With AT mode packets were formed for us and the payload was the only part we submitted in forming it. This lead us into problems as we would not be able to access information in the packet header that could be crucial to determining who sent the packet and other details. 

With API mode we were able to form the packets entirely ourselves, however this meant we required an API to handle this for us, which is what we set out to create. The API we created was able to determine different destinations, sources, error checking and packet fragmentation We had to work with the packet format the XBee expected which was found in its data sheet. This also gave us the ability to work with different types of packets such as status packets which gave us the insight of knowing whether a packet was received or not. 

The written API could handle multiple packets at once and organise them according to their sources. We could also handle packet assembly and fragmentation, so large payloads would no longer be an issue.

(Multiple sensors to Hub to server, Hub reads in data using API provided and is able to distinguish incoming packets and sources.)
 
However the XBee did not accommodate packet fragmentation itself, so in order for this to work we had to manually number each packet from each source when being fragmented and sent across the network. We also needed to be able to determine which was the final frame, this was done using an ‘!’ character, which would never naturally appear in any of our normal packets. 

Image Here
(Showing simple-flow approach to packet fragmentation. Message is split into frames, each frame is acknowledged when received and the process repeats until all frames are received successfully.)

####Node Discovery 

Being able to determine what sensors already exist on a network would offer us much more functionality. We would be able to ping nodes on the network and offer more functionality in the written API to message individual nodes. 

On startup the program running on the hub would find every current node on the network and save them. It will also load from memory any nodes it has previously found. This way, it could determine if a node was missing (Maybe a sensor was moved) and could report this back to the client. The hub would periodically send heartbeats across the network to see any changes on the nodes. If a change was detected (such as a node disappearing) it would report this back to the server, this way we could display on the website that a sensor was out of range or had run out for battery. 

With node discovery it simplified sending messages from the coordinator to sensors, instead of requiring individuals addresses. You could pass names of nodes into the “sendMessage” function and it will conclude the address based on this.

~~~python
# Send message with API, sensor1 lets the API know which 64bit
# address we’re looking for, returns successful or not
response = xbee.sendMessage("sensor1", "Hello World")
~~~

Sending ‘sensor1’ - “Hello world!”, the program will fetch the associated 64bit address of sensor1.






<style>
	.todo{ color:red }
</style>

#Orange Street

###Initial Ideas

At this point we had spoken to enough individuals to have a good place to start working on a potential prototype. We needed to plan how we would efficiently tackle the problem ahead of us. We first had to make a list of requirements based on our aims <span class="todo">link to aims</span>

* We needed multiple sensors 
* We needed the sensors to be self-sustainable for a long period of time.
* We needed the sensors to be out of the way but effective (Out of mind, not reminders to the clients), so no wires running everywhere.
* We needed a way to visualise all the data from these sensors into a form that was easily understandable
* We needed control over the network, and ideally a way to configure it.
* We needed cases that could ensure the endurance of the devices in different conditions.

Translating this to a solution we can work with:

* We were looking at some form of wireless solution, we could not afford to have wires running everywhere when the clients wanted the solution ‘out of mind’. With wireless comes many different solutions, we investigated the best options available to us.
* We know we had to sample sound - we did not know how often to sample however so we went to investigate that also.
* A microphone is needed with any other electronic circuitry that comes with it. 
* A way to display this data, we decided to investigate ways to do such a thing.
* We had to ensure some form of data backup also.
* Some of the requested locations for these sensors were completely unreachable by permanent power supplies, which led us to the investigation of long term battery solutions.
* We needed a case that could survive harsh weather and conditions, one that would be of a suitable Ingress Protection Rating.

<style>
	.todo{ color:red }
</style>

#Orange Street

### <a name="networking"></a>Networking [cont.](#contents)

Our network is a robust low powered mesh that has a coordinator handling as many routers and end points as we need. The coordinator is capable of addressing each node on the network as well as the nodes being able to address the coordinator. The hardware used to handle interaction on the network is the XBee S2 module using the ZigBee protocol communicating to our devices using serial. XBee S2 have sleep functionality and only draw 40mA upon transmitting making them ideal for a low powered solution. 

Due to the configuration behind each XBee module we were able to have full control over our own network as well as control features such as sleep modes and firmware. We are using API mode when handling XBee modules on our network, as this firmware allows us to have much more control over the network.

The sensors were programmed in C++ and the Hub was programmed in Python, so we have written two Libraries to be able to communicate in the format the XBee modules expected. Using these libraries we can have greater control over the API mode letting us know when nodes disappear on the network, or that a packet failed to transmit to name a few.

IMAGE1

IMAGE 2

Researching technologies

Because we decided that we were working with a wireless network based on our aims<span class="todo"> link to </span> and so we had to investigate potential solutions on how to transfer data, limitations like strength, distance, maximum payload and power usage all came to mind. The most obvious solution was WiFi, although with much investigation it became the least likely solution.

Here is a graph that we formulated over common low power wireless solutions, aside WiFi - but that was added just for reference.
 
IMAGE 3

WiFi

WiFi is very commercially known and accepted by all as a form wireless data transfer, so our clients would be aware of its existence. However WiFI is in no way real way designed for systems that are meant to last in theory months on end. Hence why our smartphones can lose power quickly once tapped in the local WiFi.

For our application we did not expect to be sending anything more than 10 kilobytes a day, so to have the ability to send upwards of 10 megabytes was overkill in our perspective. 

However the real selling point to using WiFi comes in two forms. Not only can we transmit longer distances but we access straight to the clients home WiFi. This could in theory also lead to the elimination of the hubs, however this would only lead towards more problems regarding data processing and one of our mains goals was to have a battery life that lasted as long as possible. One of the more problematic issues of WiFi would be the encryption, the data we are sending is not of national security nor anything that could be any real use to anyone aside our clients and in the event that our clients change their WiFi credentials (Encryption key, SSID etc) then we risk jeopardising the sensors.
Bluetooth and Bluetooth LE (Low Energy)

Bluetooth is also a viable alternative for transferring over a low bandwidth where speed is not too key an issue. Depending on how often we schedule the device to transmit data. Since the range on this is considerably lower (5-30 meters) so we would have to consider integrating this with a hub of some kind to forward our data. Fortunately some of the properties across Orange Street feature flat rooftops; upon which we could attach peripherals such as antennas if we need to.  

Bluetooth smart devices have a typically very low sleep current which equates to low power consumption when it isn’t being used. This is ideal as the device will have periods of inactivity once we decide upon which kind of timeframe it should be operating over. 

Bluetooth works on a dynamic network topology called PAN, which supports up to 8 other devices and a minimum of two, although we don’t plan on having an abundance of sensors in one house (Minimum most likely 3) 

IEEE 802

IEEE standard 802.15.4 intends to offer the fundamental lower network layers of a type of wireless personal area network (WPAN) which focuses on low-cost, low-speed ubiquitous communication between devices. 

Two types of network node:

A full-function device (FFD). It can serve as the coordinator of a personal area network just as it may function as a common node. It implements a general model of communication which allows it to talk to any other device: it may also relay messages, in which case it is dubbed a coordinator (PAN coordinator when it is in charge of the whole network).

A reduced-function devices (RFD). These are meant to be extremely simple devices with very modest resource and communication requirements; due to this, they can only communicate with FFDs and can never act as coordinators.

Although this was a low powered solution, its range is too little - although we plan on having devices communicate in houses only, (sensors to hubs) with this solution we would lack power to punch signals through walls, making our sensors have to be within line of sight of the hub.

ZigBee (XBEE) S2 and XSC

We found that the S2 in particular was more than adequate for our desires, having one of the lower current draws for transmitting/receiving data, especially that of in sleep with a good data rate (250kbps) and working on a mesh network topology.  Not only this, but the XBee offered full configurable settings on its usage and setup, allowing us greater control of the network than other alternatives.

The XBee can also be programmed manually to work on its own meaning in theory we could eliminate the Microcontroller entirely, however this solution leads to problems involving working out the current time and large packet payloads. We may come back to it at a later point, but for now we decided to use it purely for as means for A-B for our data. 

Conclusion, Configuring the XBee

Testing the range of the XBee S2 revealed some problems that were unseen before such as the range being weaker than expected when facing an urban environment. The shed being the receiver's location is simply a building in an open courtyard surrounded by other buildings. The moment we entered another building the Xbee’s communication would experience huge packet loss and eventually fail entirely. This lead to a new problem, how could we guarantee data's arrival. If the nodes on the network were out of range how could we display this to our client in a meaningful manner?

IMAGE 4

Although we didn’t need XBee’s to be able to communicate huge distances (beyond 25m) it did raise concerns - causing us to later research API mode and ways of ensuring packet robustness.

Setting up the XBee

XBees have microcontrollers onboard that store and control the instructions that let them know where data is being sent, sleep functionality, node hopping, retry attempts and much more. For our network we needed to configure each XBee to work within our desired parameters.

In order to configure these settings we required software and hardware to interface into the XBee. XCTU,software created by Digit International and a makeshift serial programmer. With this we could then start altering the settings on the firmware and adapt the XBees to our desired network structure.

IMAGE 5

When programming the XBees over serial, there are many different options for installing new firmware settings. Initially we worked with ZNet 2.5 AT for both coordinators and end routers on the network, however we later changed to working with ZNet 2.5 API as this offered more configurability.

XBees share one trait across all networks that is a requirement for them to be all to communicate, this is their PANID. The PANID is a 64 bit integer that is ideally unique on a network and separates other networks in close proximity from each other.

IMAGE 6

Using AT Command mode we had to specifically set values on the XBee. These ranged from 64bit destination address to encryption being enabled. This information was used in creating packets, however in API mode you were able to change this information at will by creating your own packets.

After we set the two XBee devices to be on the same personal network (sharing PANID), aligning their firmware (ZNet 2.5 AT), and finally setting them as coordinator and router - they were able to communicate. In AT mode we could send bytes down serial to the XBee and the firmware of that XBee would create a packet based on what we’ve set as predefined instructions. In API mode we would have to send down each individual element of the packet structure ourselves, however this allowed us to have a huge amount more control over network structure.

We needed one hub per house which could communicate and route data between sensors. The hubs were powered by mains as opposed to sensors which were powered by batteries and in varying locations. The sensors communicated using XBees to the Hub on a mesh topology, in theory allowing us to have as many sensors as we may have needed.

IMAGE 7

API vs AT

We used API mode over AT mode in the end as this offered more configurability for our network, however it was more overhead in terms of setting up. We would need to account for packet formats, error checking and versatility. With AT mode a lot of this is covered for you, however nearly all of it is hidden away and meant that we couldn’t use it.

For API mode to work in our favour, we had to create two APIs one for the sensors and the Hub. These APIs had to be able to interpret the packet format expected from the XBees (see for formatting: Hub)

IMAGE 8

The written APIs for API mode

The premise of the APIs was to create libraries that would not force the other components to be completely recoded, instead replacing one line would effectively have the same result. With AT mode, sending data was a simple matter of writing that data out to serial and we needed to keep that format. In actuality, with API mode it was not that straightforward. We needed to recreate the packet structure every time a packet was to be sent.

We needed a way to change one line into a whole new function but without changing more than just that line.

IMAGE 9

Both APIs were different and not just in language. The end point/router API was written in C++ and was only ever designed to talk to the coordinator, so when sending a message using this API - it will address the coordinator. Whereas the Python API for the Hub had to allow for the addressing of any node on the network, and had to be able to store multiple incoming packets from different sources. The end point/routers only needed to store one message at a time, and those messages were always from the coordinator who would never send more than one at a time. Due to this requirement, our written APIs did not have to accommodate for every possibility, only the ones that expect and want. 

XBees couldn’t support large packet fragmentation, which meant large payloads would simply drop. Since we were transmitting a lot of data in one go, this lead to problems arising as we had to implement our own fragmentation of packets.

For more information regarding the Hub API and packet fragmentation, see Hub.

Sleep Settings

Amongst many of the settings available on the XBee, sleep was a must have. The XBee actually had the ability to act independently as a sensor with settings being provided for polling data from pins, but due to lack of functionality we sided against using this feature. 

There were many options available to us when configuring sleep mode. Most importantly how often does the module stay asleep for and then how often to stay awake for. In terms of reserving power this feature is invaluable for the sensor. 

The sensor used a set of pins on the XBee to command it to enter sleep mode, or awake from sleep mode - thus limiting its power consumption.

Sensor out of range

We constructed a dummy sensor in order to demonstrate range testing and how to show the client this information in a meaningful manner. The dummy was created using an Arduino Uno, a set of LEDs (Green and Red) as well as a XBee breakout board. It was transmitting random floating values from one of its analog pins in the same format expected of the actual sensor. The sensor was initially given a set of LEDs; green and red. These LEDs would turn on or off depending on the circumstance, if the sensor was within range of the coordinator (The hub) the green LED would light up, else if the sensor was out of range the red LED would light up. 

Although simple in principle, this was not possible with the use of AT mode (Without doing some serious and inefficient modifications). Using status packets we could determine whether a sensor was within range or not and then use this information to alert the client. We later decided that this information could be made easier to understand if the Hub was to alert the web server when a sensor was out of range, as this information could be displayed on the website. 

IMAGE 10

Conclusion

After testing the XBees on multiple platforms, their range and customizability make them perfect for a small mesh network of sensors to hubs. For our IOT based project they seem more than suitable to fit the role for low-powered sensors reporting back. 
# orange-corpus<style>
	.todo{ color:red }
</style>

#Orange Street

### <a name="sensor"></a>Sensor [cont.](#contents)
The sensor samples sound every minute. The microphone in the sensor starts collecting sound data every minute it produces data that represents a sine wave. The data is then put through an ADC (Analogue to Digital Converter) that amplifies the analogue data (sine wave) and removes any voltage noise. It is then analysed by the sensor, taking fifty points along the wave, in this minute time period, to find the amplitude of the wave (how loud the sound is).  

The sensor is comprised of multiple parts, [Microphone](#mic), [ADC](#adc), [Board](#sensor_board), [Clock](#sensor_clock), [Battery](#battery), [XBee](#sensor_xbee), [Case](#sensor_case).  
###### <a name="mic"></a>Microphone
###### <a name="adc"></a>ADC
###### <a name="sensor_board"></a>Board
###### <a name="sensor_clock"></a>Clock
###### <a name="battery"></a>Battery
###### <a name="sensor_xbee"></a>XBee <span class="todo">unnecessary?</span>
###### <a name="sensor_case"></a>Case
The Case was designed in a way that was intended to aim our microphone at the noisy street and protect the electronics from the elements. It was 3D printed at a high fidelity (high infill of plastic) with a thickness of 3mm as not to allow water in through the printed plastic. It was then sanded and sprayed with a high fill primer to fill any pores left int the plastic left from the printing process. As the case had to be closed around the electronics of the sensor a seam was built in that was filled with a neoprene strip as to stop any water from getting through said seam.

#### Sensor Development/Iterations

Based on our [client interaction](#client_interaction) we decided that we had to make a device that measured the volume of the sound in Orange Street, collecting the data and sending it back to a server so that it is stored and can be accessed by the client to use.

The specification for the sensor meant that it had to accurately collect sound data, last for a reasonable amount of time (around a month) without being charged and be weatherproof.
<style>
	.todo{ color:red }
</style>

#Orange Street

### <a name="server"></a>Server [cont.](#contents)
<style>
	.todo{ color:red }
</style>

#Orange Street

### <a name="visualisation"></a>Visualisation [cont.](#contents)